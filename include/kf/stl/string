#pragma once
#include <kf/stl/basic_string>
#include <ntstrsafe.h>

namespace kf
{
    template <POOL_TYPE PoolType>
    using string = kf::basic_string<char, PoolType>;

    template <POOL_TYPE PoolType>
    using wstring = kf::basic_string<wchar_t, PoolType>;

#ifdef __cpp_lib_char8_t
    template <POOL_TYPE PoolType>
    using u8string = kf::basic_string<char8_t, PoolType>;
#endif // defined(__cpp_lib_char8_t)

    template <POOL_TYPE PoolType>
    using u16string = kf::basic_string<char16_t, PoolType>;

    template <POOL_TYPE PoolType>
    using u32string = kf::basic_string<char32_t, PoolType>;

    //
    // string to numeric
    //

    template <typename CharT, POOL_TYPE PoolType, typename T>
    [[nodiscard]] NTSTATUS string_to_numeric(
        _In_ const basic_string<CharT, PoolType>& str,
        _Out_ T& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        auto it = str.cbegin();
        auto end = str.cend();
        auto start = it;

        while (it != end && (*it == CharT(' ') || *it == CharT('\t')))
        {
            ++it;
        }

        bool negative = false;
        if (it != end && (*it == CharT('+') || *it == CharT('-')))
        {
            if (*it == CharT('-'))
            {
                negative = true;
            }
            ++it;
        }

        if constexpr (!std::is_signed_v<T>)
        {
            if (negative)
            {
                return STATUS_INTEGER_OVERFLOW;
            }
        }

        if (base == 16)
        {
            it += 2;
        }

        if (base == 0)
        {
            if (it != end && *it == CharT('0'))
            {
                ++it;
                if (it != end && (*it == CharT('x') || *it == CharT('X')))
                {
                    base = 16;
                    ++it;
                }
                else
                {
                    base = 8;
                }
            }
            else
            {
                base = 10;
            }
        }

        if (base < 2 || base > 36)
        {
            return STATUS_INVALID_PARAMETER;
        }

        T temp = 0;
        bool anyDigit = false;

        for (; it != end; ++it)
        {
            int digit = -1;

            if (*it >= CharT('0') && *it <= CharT('9'))
            {
                digit = *it - CharT('0');
            }
            else if (*it >= CharT('a') && *it <= CharT('z'))
            {
                digit = *it - CharT('a') + 10;
            }
            else if (*it >= CharT('A') && *it <= CharT('Z'))
            {
                digit = *it - CharT('A') + 10;
            }

            if (digit < 0 || digit >= base)
            {
                break;
            }

            anyDigit = true;

            if (negative)
            {
                if (temp < ((std::numeric_limits<T>::min)() + digit) / base)
                {
                    return STATUS_INTEGER_OVERFLOW;
                }
                temp = temp * base - digit;
            }
            else
            {
                if (temp > ((std::numeric_limits<T>::max)() - digit) / base)
                {
                    return STATUS_INTEGER_OVERFLOW;
                }
                temp = temp * base + digit;
            }
        }

        if (!anyDigit)
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (idx)
        {
            *idx = static_cast<size_t>(it - start);
        }

        result = temp;

        return STATUS_SUCCESS;
    }

    // ===== string =====
    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoi(
        _In_ const string<PoolType>& str,
        _Out_ int& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stol(
        _In_ const string<PoolType>& str,
        _Out_ long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoul(
        _In_ const string<PoolType>& str,
        _Out_ unsigned long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoll(
        _In_ const string<PoolType>& str,
        _Out_ long long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoull(
        _In_ const string<PoolType>& str,
        _Out_ unsigned long long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    // ===== wstring =====
    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoi(
        _In_ const wstring<PoolType>& str,
        _Out_ int& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stol(
        _In_ const wstring<PoolType>& str,
        _Out_ long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoul(
        _In_ const wstring<PoolType>& str,
        _Out_ unsigned long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoll(
        _In_ const wstring<PoolType>& str,
        _Out_ long long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    template <POOL_TYPE PoolType>
    [[nodiscard]] NTSTATUS stoull(
        _In_ const wstring<PoolType>& str,
        _Out_ unsigned long long& result,
        _Out_opt_ size_t* idx = nullptr,
        _In_ int base = 10
    )
    {
        return string_to_numeric(str, result, idx, base);
    }

    //
    // numeric to string
    //

    constexpr  size_t kMaxLongLongStrLength = 21;

    template <POOL_TYPE PoolType, typename T>
    [[nodiscard]] NTSTATUS to_string(T value, _Out_ kf::string<PoolType>& str)
        requires (std::is_integral_v<T>)
    {
        char buffer[kMaxLongLongStrLength]{};
        NTSTATUS status;

        if constexpr (std::is_signed_v<T>)
        {
            status = RtlStringCbPrintfA(buffer, kMaxLongLongStrLength, "%lld", static_cast<long long>(value));
        }
        else
        {
            status = RtlStringCbPrintfA(buffer, kMaxLongLongStrLength, "%llu", static_cast<unsigned long long>(value));
        }
        if (!NT_SUCCESS(status))
        {
            return status;
        }

        return str.assign(buffer);
    }

    template <POOL_TYPE PoolType, typename T>
    [[nodiscard]] NTSTATUS to_wstring(T value, _Out_ kf::wstring<PoolType>& str)
        requires (std::is_integral_v<T>)
    {
        wchar_t buffer[kMaxLongLongStrLength]{};
        NTSTATUS status;

        if constexpr (std::is_signed_v<T>)
        {
            status = RtlStringCbPrintfW(buffer, kMaxLongLongStrLength * sizeof(wchar_t), L"%lld", static_cast<long long>(value));
        }
        else
        {
            status = RtlStringCbPrintfW(buffer, kMaxLongLongStrLength * sizeof(wchar_t), L"%llu", static_cast<unsigned long long>(value));
        }
        if (!NT_SUCCESS(status))
        {
            return status;
        }

        return str.assign(buffer);
    }
}
